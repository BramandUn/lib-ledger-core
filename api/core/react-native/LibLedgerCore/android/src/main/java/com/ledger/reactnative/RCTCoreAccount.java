// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from wallet.djinni

package com.ledger.reactnative;

import co.ledger.core.Account;
import co.ledger.core.AddressListCallback;
import co.ledger.core.AmountCallback;
import co.ledger.core.AmountListCallback;
import co.ledger.core.BitcoinLikeAccount;
import co.ledger.core.BlockCallback;
import co.ledger.core.ErrorCodeCallback;
import co.ledger.core.EventBus;
import co.ledger.core.Logger;
import co.ledger.core.OperationQuery;
import co.ledger.core.Preferences;
import co.ledger.core.TimePeriod;
import co.ledger.core.WalletType;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

/**Class representing an account */
public class RCTCoreAccount extends ReactContextBaseJavaModule {

    private final ReactApplicationContext reactContext;
    private Map<String, Account> javaObjects;
    public Map<String, Account> getJavaObjects()
    {
        return javaObjects;
    }

    public RCTCoreAccount(ReactApplicationContext reactContext)
    {
        super(reactContext);
        this.reactContext = reactContext;
        this.javaObjects = new HashMap<String, Account>();
    }

    @Override
    public String getName()
    {
        return "RCTCoreAccount";
    }

    /**
     *Get index of account in user's wallet
     *32 bits integer
     */
    @ReactMethod
    public void getIndex(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to getIndex method");
            }

            int javaResult = currentInstanceObj.getIndex();
            Map<String, int> result = new HashMap<String, int>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::getIndex : Failed to return int from getIndex method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**TODO */
    @ReactMethod
    public void queryOperations(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to queryOperations method");
            }

            OperationQuery javaResult = currentInstanceObj.queryOperations();

            String uuid = UUID.randomUUID().toString();
            RCTCoreOperationQuery rctImpl_javaResult = this.reactContext.getNativeModule(RCTCoreOperationQuery.class);
            rctImpl_javaResult.getJavaObjects.put(uuid, javaResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreOperationQuery");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::queryOperations : Failed to return OperationQuery from queryOperations method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Get balance of account
     *@param callback, if getBalacne, Callback returning an Amount object which represents account's balance
     */
    @ReactMethod
    public void getBalance(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to getBalance method");
            }

            RCTCoreAmountCallback javaParam_0 = RCTCoreAmountCallback.initWithPromise(promise, this.reactContext);
            currentInstanceObj.getBalance(javaParam_0);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Get balance of account at a precise interval with a certain granularity
     *@param start, lower bound of search range
     *@param end, upper bound of search range
     *@param precision, granularity at which we want results
     *@param callback, ListCallback returning a list of Amount object which represents account's balance
     */
    @ReactMethod
    public void getBalanceHistory(Map<String, String> currentInstance, String start, String end, TimePeriod period, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to getBalanceHistory method");
            }

            RCTCoreAmountListCallback javaParam_3 = RCTCoreAmountListCallback.initWithPromise(promise, this.reactContext);
            currentInstanceObj.getBalanceHistory(start, end, period, javaParam_3);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Get synchronization status of account
     *@return bool
     */
    @ReactMethod
    public void isSynchronizing(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to isSynchronizing method");
            }

            boolean javaResult = currentInstanceObj.isSynchronizing();
            Map<String, boolean> result = new HashMap<String, boolean>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::isSynchronizing : Failed to return boolean from isSynchronizing method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Start synchronization of account
     *@return EventBus, handler will be notified of synchronization outcome
     */
    @ReactMethod
    public void synchronize(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to synchronize method");
            }

            EventBus javaResult = currentInstanceObj.synchronize();

            String uuid = UUID.randomUUID().toString();
            RCTCoreEventBus rctImpl_javaResult = this.reactContext.getNativeModule(RCTCoreEventBus.class);
            rctImpl_javaResult.getJavaObjects.put(uuid, javaResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreEventBus");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::synchronize : Failed to return EventBus from synchronize method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Return account's preferences
     *@return Preferences object
     */
    @ReactMethod
    public void getPreferences(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to getPreferences method");
            }

            Preferences javaResult = currentInstanceObj.getPreferences();

            String uuid = UUID.randomUUID().toString();
            RCTCorePreferences rctImpl_javaResult = this.reactContext.getNativeModule(RCTCorePreferences.class);
            rctImpl_javaResult.getJavaObjects.put(uuid, javaResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCorePreferences");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::getPreferences : Failed to return Preferences from getPreferences method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Return account's logger which provides all needed (e.g. database) logs
     *@return Logger Object
     */
    @ReactMethod
    public void getLogger(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to getLogger method");
            }

            Logger javaResult = currentInstanceObj.getLogger();

            String uuid = UUID.randomUUID().toString();
            RCTCoreLogger rctImpl_javaResult = this.reactContext.getNativeModule(RCTCoreLogger.class);
            rctImpl_javaResult.getJavaObjects.put(uuid, javaResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreLogger");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::getLogger : Failed to return Logger from getLogger method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Return preferences of specific operation
     *@param uid, string of operation id
     *@return Preferences
     *Return operation for a specific operation
     *@param uid, string of operation id
     */
    @ReactMethod
    public void getOperationPreferences(Map<String, String> currentInstance, String uid, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to getOperationPreferences method");
            }

            Preferences javaResult = currentInstanceObj.getOperationPreferences(uid);

            String uuid = UUID.randomUUID().toString();
            RCTCorePreferences rctImpl_javaResult = this.reactContext.getNativeModule(RCTCorePreferences.class);
            rctImpl_javaResult.getJavaObjects.put(uuid, javaResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCorePreferences");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::getOperationPreferences : Failed to return Preferences from getOperationPreferences method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    @ReactMethod
    public void asBitcoinLikeAccount(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to asBitcoinLikeAccount method");
            }

            BitcoinLikeAccount javaResult = currentInstanceObj.asBitcoinLikeAccount();

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeAccount rctImpl_javaResult = this.reactContext.getNativeModule(RCTCoreBitcoinLikeAccount.class);
            rctImpl_javaResult.getJavaObjects.put(uuid, javaResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeAccount");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::asBitcoinLikeAccount : Failed to return BitcoinLikeAccount from asBitcoinLikeAccount method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * asEthereumLikeAccount(): Callback<EthereumLikeAccount>;
     * asRippleLikeAccount(): Callback<RippleLikeAccount>;
     *Check if account is a Bitcoin one
     *@return bool
     */
    @ReactMethod
    public void isInstanceOfBitcoinLikeAccount(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to isInstanceOfBitcoinLikeAccount method");
            }

            boolean javaResult = currentInstanceObj.isInstanceOfBitcoinLikeAccount();
            Map<String, boolean> result = new HashMap<String, boolean>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::isInstanceOfBitcoinLikeAccount : Failed to return boolean from isInstanceOfBitcoinLikeAccount method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Check if account is an Ethereum one
     *@return bool
     */
    @ReactMethod
    public void isInstanceOfEthereumLikeAccount(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to isInstanceOfEthereumLikeAccount method");
            }

            boolean javaResult = currentInstanceObj.isInstanceOfEthereumLikeAccount();
            Map<String, boolean> result = new HashMap<String, boolean>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::isInstanceOfEthereumLikeAccount : Failed to return boolean from isInstanceOfEthereumLikeAccount method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Check if account is a Ripple one
     *@return bool
     */
    @ReactMethod
    public void isInstanceOfRippleLikeAccount(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to isInstanceOfRippleLikeAccount method");
            }

            boolean javaResult = currentInstanceObj.isInstanceOfRippleLikeAccount();
            Map<String, boolean> result = new HashMap<String, boolean>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::isInstanceOfRippleLikeAccount : Failed to return boolean from isInstanceOfRippleLikeAccount method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**TODO */
    @ReactMethod
    public void getFreshPublicAddresses(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to getFreshPublicAddresses method");
            }

            RCTCoreAddressListCallback javaParam_0 = RCTCoreAddressListCallback.initWithPromise(promise, this.reactContext);
            currentInstanceObj.getFreshPublicAddresses(javaParam_0);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Get type of wallet to which account belongs
     *@return WalletType object
     */
    @ReactMethod
    public void getWalletType(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to getWalletType method");
            }

            WalletType javaResult = currentInstanceObj.getWalletType();
            Map<String, WalletType> result = new HashMap<String, WalletType>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::getWalletType : Failed to return WalletType from getWalletType method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Get event bus through which account is notified on synchronization status
     *@return EventBus object
     */
    @ReactMethod
    public void getEventBus(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to getEventBus method");
            }

            EventBus javaResult = currentInstanceObj.getEventBus();

            String uuid = UUID.randomUUID().toString();
            RCTCoreEventBus rctImpl_javaResult = this.reactContext.getNativeModule(RCTCoreEventBus.class);
            rctImpl_javaResult.getJavaObjects.put(uuid, javaResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreEventBus");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::getEventBus : Failed to return EventBus from getEventBus method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**Start observing blockchain on which account synchronizes and send/receive transactions */
    @ReactMethod
    public void startBlockchainObservation(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to startBlockchainObservation method");
            }

            currentInstanceObj.startBlockchainObservation();
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**Stop observing blockchain */
    @ReactMethod
    public void stopBlockchainObservation(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to stopBlockchainObservation method");
            }

            currentInstanceObj.stopBlockchainObservation();
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Get account's observation status
     *@return boolean
     */
    @ReactMethod
    public void isObservingBlockchain(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to isObservingBlockchain method");
            }

            boolean javaResult = currentInstanceObj.isObservingBlockchain();
            Map<String, boolean> result = new HashMap<String, boolean>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::isObservingBlockchain : Failed to return boolean from isObservingBlockchain method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Get Last block of blockchain on which account operates
     *@param callback, Callback returning, if getLastBlock succeeds, a Block object
     */
    @ReactMethod
    public void getLastBlock(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to getLastBlock method");
            }

            RCTCoreBlockCallback javaParam_0 = RCTCoreBlockCallback.initWithPromise(promise, this.reactContext);
            currentInstanceObj.getLastBlock(javaParam_0);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Get the key used to generate the account */
    @ReactMethod
    public void getRestoreKey(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to getRestoreKey method");
            }

            String javaResult = currentInstanceObj.getRestoreKey();
            Map<String, String> result = new HashMap<String, String>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreAccount::getRestoreKey : Failed to return String from getRestoreKey method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Erase data (in user's DB) relative to wallet since given date
     *@param date, start date of data deletion
     */
    @ReactMethod
    public void eraseDataSince(Map<String, String> currentInstance, Date date, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Account currentInstanceObj = this.javaObjects.get("uid");
            if (!currentInstanceObj)
            {
                throw new Exception("Wrong RCTCoreAccount instance passed to eraseDataSince method");
            }

            RCTCoreErrorCodeCallback javaParam_1 = RCTCoreErrorCodeCallback.initWithPromise(promise, this.reactContext);
            currentInstanceObj.eraseDataSince(date, javaParam_1);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
}
