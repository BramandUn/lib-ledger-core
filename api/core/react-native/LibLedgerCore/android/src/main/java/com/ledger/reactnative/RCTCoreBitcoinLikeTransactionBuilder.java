// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from bitcoin_like_wallet.djinni

package com.ledger.reactnative;

import BitcoinLikeTransactionBuilder;
import RCTCoreAmount;
import RCTCoreBitcoinLikeScript;
import RCTCoreBitcoinLikeTransaction;
import RCTCoreBitcoinLikeTransactionBuilder;
import RCTCoreBitcoinLikeTransactionCallback;
import RCTCoreCurrency;
import co.ledger.core.Amount;
import co.ledger.core.BitcoinLikePickingStrategy;
import co.ledger.core.BitcoinLikeScript;
import co.ledger.core.BitcoinLikeTransaction;
import co.ledger.core.BitcoinLikeTransactionBuilder;
import co.ledger.core.BitcoinLikeTransactionCallback;
import co.ledger.core.Currency;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import java.util.UUID;;

public class RCTCoreBitcoinLikeTransactionBuilder extends ReactContextBaseJavaModule {

    private final ReactApplicationContext reactContext;
    private Map<String, BitcoinLikeTransactionBuilder> javaObjects;

    public RNLedgerCoreModule(ReactApplicationContext reactContext)
    {
        super(reactContext);
        this.reactContext = reactContext;
        this.javaObjects = new HashMap<String, BitcoinLikeTransactionBuilder>();
    }

    @Override
    public String getName()
    {
        return "RCTCoreBitcoinLikeTransactionBuilder";
    }

    /**
     * Add the given input to the final transaction.
     * @param transactionhash The hash of the transaction in where the UTXO can be located.
     * @params index Index of the UTXO in the previous transaction
     * @params sequence Sequence number to add at the end of the input serialization. This can be used for RBF transaction
     * @return A reference on the same builder in order to chain calls.
     */
    @ReactMethod
    public void addInput(Map<String, String> currentInstance, String transactionHash, int index, int sequence, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to addInput method");
            }

            BitcoinLikeTransactionBuilder javaResult = currentInstanceObj.addInput(transactionHash, index, sequence);

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransactionBuilder rctImpl_objcResult = (RCTCoreBitcoinLikeTransactionBuilder)self.bridge moduleForName("RCTCoreBitcoinLikeTransactionBuilder");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransactionBuilder");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::addInput : Failed to return BitcoinLikeTransactionBuilder from addInput method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * Add the given output to the final transaction
     * @return A reference on the same builder in order to chain calls.
     */
    @ReactMethod
    public void addOutput(Map<String, String> currentInstance, HashMap <String, String> amount, HashMap <String, String> script, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to addOutput method");
            }

            RCTCoreAmount rctParam_amount = (RCTCoreAmount)self.bridge.moduleForName("RCTCoreAmount");
            Amount javaParam_0 = (Amount)rctParam_amount.javaObjects.get(amount.get("uid"));
            RCTCoreBitcoinLikeScript rctParam_script = (RCTCoreBitcoinLikeScript)self.bridge.moduleForName("RCTCoreBitcoinLikeScript");
            BitcoinLikeScript javaParam_1 = (BitcoinLikeScript)rctParam_script.javaObjects.get(script.get("uid"));
            BitcoinLikeTransactionBuilder javaResult = currentInstanceObj.addOutput(javaParam_0, javaParam_1);

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransactionBuilder rctImpl_objcResult = (RCTCoreBitcoinLikeTransactionBuilder)self.bridge moduleForName("RCTCoreBitcoinLikeTransactionBuilder");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransactionBuilder");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::addOutput : Failed to return BitcoinLikeTransactionBuilder from addOutput method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * If needed the transaction will send its change to the given path. It is possible to add multiple change path.
     * @return A reference on the same builder in order to chain calls.
     */
    @ReactMethod
    public void addChangePath(Map<String, String> currentInstance, String path, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to addChangePath method");
            }

            BitcoinLikeTransactionBuilder javaResult = currentInstanceObj.addChangePath(path);

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransactionBuilder rctImpl_objcResult = (RCTCoreBitcoinLikeTransactionBuilder)self.bridge moduleForName("RCTCoreBitcoinLikeTransactionBuilder");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransactionBuilder");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::addChangePath : Failed to return BitcoinLikeTransactionBuilder from addChangePath method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * Exclude UTXO from the coin selection (alias UTXO picking). You can call this method multiple times to exclude multiple
     * UTXO.
     * @param transactionHash The hash of the transaction in which this UTXO can be found.
     * @param outputIndex The position of the output in the previous transaction,
     * @return A reference on the same builder in order to chain calls.
     */
    @ReactMethod
    public void excludeUtxo(Map<String, String> currentInstance, String transactionHash, int outputIndex, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to excludeUtxo method");
            }

            BitcoinLikeTransactionBuilder javaResult = currentInstanceObj.excludeUtxo(transactionHash, outputIndex);

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransactionBuilder rctImpl_objcResult = (RCTCoreBitcoinLikeTransactionBuilder)self.bridge moduleForName("RCTCoreBitcoinLikeTransactionBuilder");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransactionBuilder");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::excludeUtxo : Failed to return BitcoinLikeTransactionBuilder from excludeUtxo method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** @return A reference on the same builder in order to chain calls. */
    @ReactMethod
    public void setNumberOfChangeAddresses(Map<String, String> currentInstance, int count, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to setNumberOfChangeAddresses method");
            }

            BitcoinLikeTransactionBuilder javaResult = currentInstanceObj.setNumberOfChangeAddresses(count);

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransactionBuilder rctImpl_objcResult = (RCTCoreBitcoinLikeTransactionBuilder)self.bridge moduleForName("RCTCoreBitcoinLikeTransactionBuilder");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransactionBuilder");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::setNumberOfChangeAddresses : Failed to return BitcoinLikeTransactionBuilder from setNumberOfChangeAddresses method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * Set the maximum amount per change output. By default there is no max amount.
     * @return A reference on the same builder in order to chain calls.
     */
    @ReactMethod
    public void setMaxAmountOnChange(Map<String, String> currentInstance, HashMap <String, String> amount, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to setMaxAmountOnChange method");
            }

            RCTCoreAmount rctParam_amount = (RCTCoreAmount)self.bridge.moduleForName("RCTCoreAmount");
            Amount javaParam_0 = (Amount)rctParam_amount.javaObjects.get(amount.get("uid"));
            BitcoinLikeTransactionBuilder javaResult = currentInstanceObj.setMaxAmountOnChange(javaParam_0);

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransactionBuilder rctImpl_objcResult = (RCTCoreBitcoinLikeTransactionBuilder)self.bridge moduleForName("RCTCoreBitcoinLikeTransactionBuilder");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransactionBuilder");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::setMaxAmountOnChange : Failed to return BitcoinLikeTransactionBuilder from setMaxAmountOnChange method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * Set the minimum amount per change output. By default this value is the dust value of the currency.
     * @return A reference on the same builder in order to chain calls.
     */
    @ReactMethod
    public void setMinAmountOnChange(Map<String, String> currentInstance, HashMap <String, String> amount, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to setMinAmountOnChange method");
            }

            RCTCoreAmount rctParam_amount = (RCTCoreAmount)self.bridge.moduleForName("RCTCoreAmount");
            Amount javaParam_0 = (Amount)rctParam_amount.javaObjects.get(amount.get("uid"));
            BitcoinLikeTransactionBuilder javaResult = currentInstanceObj.setMinAmountOnChange(javaParam_0);

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransactionBuilder rctImpl_objcResult = (RCTCoreBitcoinLikeTransactionBuilder)self.bridge moduleForName("RCTCoreBitcoinLikeTransactionBuilder");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransactionBuilder");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::setMinAmountOnChange : Failed to return BitcoinLikeTransactionBuilder from setMinAmountOnChange method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * Set the UTXO picking strategy (see [[BitcoinLikePickingStrategy]]).
     * @param strategy The strategy to adopt in order to select which input to use in the transaction.
     * @param sequence The sequence value serialized at the end of the raw transaction. If you don't know what to put here
     * just use 0xFFFFFF
     * @return A reference on the same builder in order to chain calls.
     */
    @ReactMethod
    public void pickInputs(Map<String, String> currentInstance, BitcoinLikePickingStrategy strategy, int sequence, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to pickInputs method");
            }

            BitcoinLikeTransactionBuilder javaResult = currentInstanceObj.pickInputs(strategy, sequence);

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransactionBuilder rctImpl_objcResult = (RCTCoreBitcoinLikeTransactionBuilder)self.bridge moduleForName("RCTCoreBitcoinLikeTransactionBuilder");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransactionBuilder");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::pickInputs : Failed to return BitcoinLikeTransactionBuilder from pickInputs method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * Send funds to the given address. This method can be called multiple times to send to multiple addresses.
     * @param amount The value to send
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    @ReactMethod
    public void sendToAddress(Map<String, String> currentInstance, HashMap <String, String> amount, String address, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to sendToAddress method");
            }

            RCTCoreAmount rctParam_amount = (RCTCoreAmount)self.bridge.moduleForName("RCTCoreAmount");
            Amount javaParam_0 = (Amount)rctParam_amount.javaObjects.get(amount.get("uid"));
            BitcoinLikeTransactionBuilder javaResult = currentInstanceObj.sendToAddress(javaParam_0, address);

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransactionBuilder rctImpl_objcResult = (RCTCoreBitcoinLikeTransactionBuilder)self.bridge moduleForName("RCTCoreBitcoinLikeTransactionBuilder");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransactionBuilder");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::sendToAddress : Failed to return BitcoinLikeTransactionBuilder from sendToAddress method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * Send all available funds to the given address.
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    @ReactMethod
    public void wipeToAddress(Map<String, String> currentInstance, String address, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to wipeToAddress method");
            }

            BitcoinLikeTransactionBuilder javaResult = currentInstanceObj.wipeToAddress(address);

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransactionBuilder rctImpl_objcResult = (RCTCoreBitcoinLikeTransactionBuilder)self.bridge moduleForName("RCTCoreBitcoinLikeTransactionBuilder");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransactionBuilder");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::wipeToAddress : Failed to return BitcoinLikeTransactionBuilder from wipeToAddress method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * Set the amount of fees per byte (of the raw transaction).
     * @return A reference on the same builder in order to chain calls.
     */
    @ReactMethod
    public void setFeesPerByte(Map<String, String> currentInstance, HashMap <String, String> fees, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to setFeesPerByte method");
            }

            RCTCoreAmount rctParam_fees = (RCTCoreAmount)self.bridge.moduleForName("RCTCoreAmount");
            Amount javaParam_0 = (Amount)rctParam_fees.javaObjects.get(fees.get("uid"));
            BitcoinLikeTransactionBuilder javaResult = currentInstanceObj.setFeesPerByte(javaParam_0);

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransactionBuilder rctImpl_objcResult = (RCTCoreBitcoinLikeTransactionBuilder)self.bridge moduleForName("RCTCoreBitcoinLikeTransactionBuilder");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransactionBuilder");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::setFeesPerByte : Failed to return BitcoinLikeTransactionBuilder from setFeesPerByte method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Build a transaction from the given builder parameters. */
    @ReactMethod
    public void build(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to build method");
            }

            RCTCoreBitcoinLikeTransactionCallback javaParam_0 = rctParamType.initWithPromise(promise, self.bridge);
            currentInstanceObj.build(javaParam_0);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * Creates a clone of this builder.
     * @return A copy of the current builder instance.
     */
    @ReactMethod
    public void clone(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to clone method");
            }

            BitcoinLikeTransactionBuilder javaResult = currentInstanceObj.clone();

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransactionBuilder rctImpl_objcResult = (RCTCoreBitcoinLikeTransactionBuilder)self.bridge moduleForName("RCTCoreBitcoinLikeTransactionBuilder");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransactionBuilder");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::clone : Failed to return BitcoinLikeTransactionBuilder from clone method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Reset the current instance to its initial state */
    @ReactMethod
    public void reset(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransactionBuilder currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransactionBuilder instance passed to reset method");
            }

            currentInstanceObj.reset();
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    @ReactMethod
    public void parseRawUnsignedTransaction(Map<String, String> currentInstance, HashMap <String, String> currency, byte[] rawTransaction, Promise promise) {
        try
        {
            BitcoinLikeTransaction javaResult = BitcoinLikeTransactionBuilder.parseRawUnsignedTransaction(javaParam_0, rawTransaction);

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeTransaction rctImpl_objcResult = (RCTCoreBitcoinLikeTransaction)self.bridge moduleForName("RCTCoreBitcoinLikeTransaction");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeTransaction");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransactionBuilder::parseRawUnsignedTransaction : Failed to return BitcoinLikeTransaction from parseRawUnsignedTransaction method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
}
