// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from wallet_pool.djinni

package com.ledger.reactnative;

import RCTCoreBlockCallback;
import RCTCoreCurrency;
import RCTCoreCurrencyCallback;
import RCTCoreCurrencyListCallback;
import RCTCoreDatabaseBackend;
import RCTCoreDynamicObject;
import RCTCoreErrorCodeCallback;
import RCTCoreEventBus;
import RCTCoreHttpClient;
import RCTCoreI32Callback;
import RCTCoreLogPrinter;
import RCTCoreLogger;
import RCTCorePathResolver;
import RCTCorePreferences;
import RCTCoreRandomNumberGenerator;
import RCTCoreThreadDispatcher;
import RCTCoreWalletCallback;
import RCTCoreWalletListCallback;
import RCTCoreWalletPool;
import RCTCoreWebSocketClient;
import WalletPool;
import co.ledger.core.BlockCallback;
import co.ledger.core.Currency;
import co.ledger.core.CurrencyCallback;
import co.ledger.core.CurrencyListCallback;
import co.ledger.core.DatabaseBackend;
import co.ledger.core.DynamicObject;
import co.ledger.core.ErrorCodeCallback;
import co.ledger.core.EventBus;
import co.ledger.core.HttpClient;
import co.ledger.core.I32Callback;
import co.ledger.core.LogPrinter;
import co.ledger.core.Logger;
import co.ledger.core.PathResolver;
import co.ledger.core.Preferences;
import co.ledger.core.RandomNumberGenerator;
import co.ledger.core.ThreadDispatcher;
import co.ledger.core.WalletCallback;
import co.ledger.core.WalletListCallback;
import co.ledger.core.WalletPool;
import co.ledger.core.WebSocketClient;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import java.util.Date;
import java.util.UUID;;

/**Class respresenting a pool of wallets */
public class RCTCoreWalletPool extends ReactContextBaseJavaModule {

    private final ReactApplicationContext reactContext;
    private Map<String, WalletPool> javaObjects;

    public RNLedgerCoreModule(ReactApplicationContext reactContext)
    {
        super(reactContext);
        this.reactContext = reactContext;
        this.javaObjects = new HashMap<String, WalletPool>();
    }

    @Override
    public String getName()
    {
        return "RCTCoreWalletPool";
    }

    /**
     *Create a new instance of WalletPool object
     *@param name, string, name of the wallet pool
     *@param password, optional string, password to lock wallet pool
     *@param http, HttpClient object, http client used for all calls made by wallet pool (and aggregated wallets)
     *@param webSocketClient, WebSocketClient object, socket through which wallet pool observe and get notified (explorer, DBs ...)
     *@param pathResolver, PathResolver Object, resolve paths to logs, databases, preferences ...
     *@param logPrinter, LogPrinter object, used to dump/log for debug purpose
     *@param dispatcher, ThreadDispatcher object, responsable of dispatching task through available threads
     *@param rng, RandomNumberGenerator object, needed for generating random numbers (for seeds, salts ...)
     *@param backend, DatabseBackend object, DB in which wallet pool store all required infos (created wallets, their options, their accounts ...)
     *@param configuration, DynamicObject object, desired configuration for this wallet pool
     *@return WalletPool object, instance of WalletPool
     */
    @ReactMethod
    public void newInstance(Map<String, String> currentInstance, String name, String password, HashMap <String, String> httpClient, HashMap <String, String> webSocketClient, HashMap <String, String> pathResolver, HashMap <String, String> logPrinter, HashMap <String, String> dispatcher, HashMap <String, String> rng, HashMap <String, String> backend, HashMap <String, String> configuration, Promise promise) {
        try
        {
            WalletPool javaResult = WalletPool.newInstance(name, password, javaParam_2, javaParam_3, javaParam_4, javaParam_5, javaParam_6, javaParam_7, javaParam_8, javaParam_9);

            String uuid = UUID.randomUUID().toString();
            RCTCoreWalletPool rctImpl_objcResult = (RCTCoreWalletPool)self.bridge moduleForName("RCTCoreWalletPool");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreWalletPool");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreWalletPool::newInstance : Failed to return WalletPool from newInstance method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Return used logger to dump logs in defined log path by PathResolver
     *@return Logger object
     */
    @ReactMethod
    public void getLogger(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            WalletPool currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreWalletPool instance passed to getLogger method");
            }

            Logger javaResult = currentInstanceObj.getLogger();

            String uuid = UUID.randomUUID().toString();
            RCTCoreLogger rctImpl_objcResult = (RCTCoreLogger)self.bridge moduleForName("RCTCoreLogger");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreLogger");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreWalletPool::getLogger : Failed to return Logger from getLogger method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Return name given to wallet pool
     *@return string
     */
    @ReactMethod
    public void getName(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            WalletPool currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreWalletPool instance passed to getName method");
            }

            String javaResult = currentInstanceObj.getName();
            Map<String, String> result = new HashMap<String, String>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreWalletPool::getName : Failed to return String from getName method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Return preferences of wallet pool (deduced from configuration)
     *@return Preferences object
     */
    @ReactMethod
    public void getPreferences(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            WalletPool currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreWalletPool instance passed to getPreferences method");
            }

            Preferences javaResult = currentInstanceObj.getPreferences();

            String uuid = UUID.randomUUID().toString();
            RCTCorePreferences rctImpl_objcResult = (RCTCorePreferences)self.bridge moduleForName("RCTCorePreferences");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCorePreferences");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreWalletPool::getPreferences : Failed to return Preferences from getPreferences method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Return number of wallets instanciated under wallet pool
     *@param callback, Callback object returns a 32 bits integer, count of wallets
     */
    @ReactMethod
    public void getWalletCount(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            WalletPool currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreWalletPool instance passed to getWalletCount method");
            }

            RCTCoreI32Callback javaParam_0 = rctParamType.initWithPromise(promise, self.bridge);
            currentInstanceObj.getWalletCount(javaParam_0);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Get instanciated wallets having index in a given range
     *@param from, 32 bits integer, lower bound of indices to pick
     *@param to, 32 bits integer, upper bound of indices to pick
     *@param callback, ListCallback object returns a list of Wallet objects
     */
    @ReactMethod
    public void getWallets(Map<String, String> currentInstance, int from, int size, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            WalletPool currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreWalletPool instance passed to getWallets method");
            }

            RCTCoreWalletListCallback javaParam_2 = rctParamType.initWithPromise(promise, self.bridge);
            currentInstanceObj.getWallets(from, size, javaParam_2);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Get wallet with a giver name
     *@param name, string, name of wallet to look for
     *@param callback, Callback object returns a Wallet object
     */
    @ReactMethod
    public void getWallet(Map<String, String> currentInstance, String name, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            WalletPool currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreWalletPool instance passed to getWallet method");
            }

            RCTCoreWalletCallback javaParam_1 = rctParamType.initWithPromise(promise, self.bridge);
            currentInstanceObj.getWallet(name, javaParam_1);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Instanciate a new wallet under wallet pool
     *@param name, string, name of newly created wallet
     *@param currency, Currency object, currency of the wallet
     *@param configuration, DynamicObject object, configuration of wallet (preferences)
     *@param callback, Callback object returning a Wallet object
     */
    @ReactMethod
    public void createWallet(Map<String, String> currentInstance, String name, HashMap <String, String> currency, HashMap <String, String> configuration, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            WalletPool currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreWalletPool instance passed to createWallet method");
            }

            RCTCoreCurrency rctParam_currency = (RCTCoreCurrency)self.bridge.moduleForName("RCTCoreCurrency");
            Currency javaParam_1 = (Currency)rctParam_currency.javaObjects.get(currency.get("uid"));
            RCTCoreDynamicObject rctParam_configuration = (RCTCoreDynamicObject)self.bridge.moduleForName("RCTCoreDynamicObject");
            DynamicObject javaParam_2 = (DynamicObject)rctParam_configuration.javaObjects.get(configuration.get("uid"));
            RCTCoreWalletCallback javaParam_3 = rctParamType.initWithPromise(promise, self.bridge);
            currentInstanceObj.createWallet(name, javaParam_1, javaParam_2, javaParam_3);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Return all supported currencies by wallet pool, at least one wallet support one of returned currencies
     *@param callback, ListCallback object, returns a list of Currency objects
     */
    @ReactMethod
    public void getCurrencies(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            WalletPool currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreWalletPool instance passed to getCurrencies method");
            }

            RCTCoreCurrencyListCallback javaParam_0 = rctParamType.initWithPromise(promise, self.bridge);
            currentInstanceObj.getCurrencies(javaParam_0);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Return currency of a specific wallet
     *@param name, wallet's name to look for
     *@param callback, Callback object returning a Currency object
     */
    @ReactMethod
    public void getCurrency(Map<String, String> currentInstance, String name, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            WalletPool currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreWalletPool instance passed to getCurrency method");
            }

            RCTCoreCurrencyCallback javaParam_1 = rctParamType.initWithPromise(promise, self.bridge);
            currentInstanceObj.getCurrency(name, javaParam_1);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Return last block of blockchain of a given currency (if it is supported by the wallet pool)
     *@param name, string, name of currency we are interested into getting it's blockchain's last block
     *@param callback, Callback object returns a Block object
     */
    @ReactMethod
    public void getLastBlock(Map<String, String> currentInstance, String currencyName, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            WalletPool currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreWalletPool instance passed to getLastBlock method");
            }

            RCTCoreBlockCallback javaParam_1 = rctParamType.initWithPromise(promise, self.bridge);
            currentInstanceObj.getLastBlock(currencyName, javaParam_1);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Get event bus (handler) through which wallet pool observe and gets notified (explorers, DBs ...)
     *@param EventBus object
     */
    @ReactMethod
    public void getEventBus(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            WalletPool currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreWalletPool instance passed to getEventBus method");
            }

            EventBus javaResult = currentInstanceObj.getEventBus();

            String uuid = UUID.randomUUID().toString();
            RCTCoreEventBus rctImpl_objcResult = (RCTCoreEventBus)self.bridge moduleForName("RCTCoreEventBus");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreEventBus");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreWalletPool::getEventBus : Failed to return EventBus from getEventBus method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Erase data (in user's DB) relative to wallet since given date
     *@param date, start date of data deletion
     */
    @ReactMethod
    public void eraseDataSince(Map<String, String> currentInstance, Date date, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            WalletPool currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreWalletPool instance passed to eraseDataSince method");
            }

            RCTCoreErrorCodeCallback javaParam_1 = rctParamType.initWithPromise(promise, self.bridge);
            currentInstanceObj.eraseDataSince(date, javaParam_1);
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
}
